# üõ†Ô∏è OpenSeal: Usage & Safety Guide

This guide covers how to set up, execute, and safely manage your OpenSeal-protected services.

---

## 1. 5-Minute Quickstart

### Step 1: Install CLI
```bash
# Download and install the latest binary for your OS
curl -L https://github.com/Gnomone/openseal/releases/latest/download/install.sh | bash
```

### Step 2: Seal (Build)
```bash
# Run at your project root
# --exec: Specify the entry command (Required)
# --deps: (Optional) Custom dependency folder to link (e.g., venv, libs)
openseal build --exec "node app.js" --output dist_opensealed
```

### Step 3: Run (Sealing Active)
```bash
# --app: Path to the sealed bundle
# --port: Public port to expose
openseal run --app dist_opensealed --port 3000
```

### Step 3-1: Run in Background (Production)
```bash
# Run in daemon mode (background)
openseal run --app dist_opensealed --port 3000 --daemon

# View logs
tail -f openseal.log

# Stop the service
pkill -f 'openseal run'
```

> [!TIP]
> Use `--daemon` flag to keep the service running even after SSH disconnection.

---

## üí° Recommended Setup by Language

### üü¢ Node.js
- **Standard**: If `node_modules` is at the root, it‚Äôs linked automatically.
- **Example**:
  ```bash
  openseal build --exec "npm run dev" --output dist_opensealed
  ```

### üü° Python
- **Standard**: Automatically detects `venv`, `.venv`, or `env`.
- **Custom**: If your environment is named `my_env`:
  ```bash
  openseal build --exec "python main.py" --deps my_env --output dist_opensealed
  ```

### üîµ Go / Rust
- For compiled binaries, ensure the binary is included in the sealed bundle.
- **Example**:
  ```bash
  openseal build --exec "./my_app" --output dist_opensealed
  ```

---

## üõ†Ô∏è Option Details

| Option | Description | Note |
| :--- | :--- | :--- |
| `--exec` | The command to start your service inside the sealed environment. | e.g., `npm run dev`, `python app.py` |
| `--deps` | Dependency path to exclude from A-Hash but link to the runtime. | Default auto-detects `node_modules`, `venv` |
| `--output` | Directory for the sealed artifacts. | Recommended to use a separate folder |

### üîµ Standard Identity Endpoint
Any service running with `openseal run` automatically exposes a standard audit endpoint at `/.openseal/identity`. This allows external tools like **HighStation** to verify code integrity in real-time without requiring any modifications to your application code.
- **URL**: `http://your-service:port/.openseal/identity`
- **Method**: `GET`
- **Returns**: Current A-Hash (Code Identity) and runtime metadata.

---

## 2. Quickstart by Language

OpenSeal recommends executing verified source code directly (JIT). Here are copy-pasteable commands for each environment.

### üü¢ Node.js (TypeScript)
For **Source Code Integrity**, we recommend using `tsx` (or `ts-node`) instead of the compiled `dist`.
*Note: For modern ESM projects, `tsx` is highly recommended for stability.*
```bash
# Build
openseal build --exec "npx tsx src/index.ts" --output dist_opensealed

# Or register "dev": "tsx src/index.ts" in package.json and run:
openseal build --exec "npm run dev" --output dist_opensealed

# Execution
cd dist_opensealed && npm install && cd ..
openseal run --app dist_opensealed --port 3000
```

### üü° Python
```bash
# Build
openseal build --exec "python main.py" --output dist_opensealed

# Execution (Activate venv if needed)
openseal run --app dist_opensealed --port 3000
```

### üîµ Go
```bash
# Build
openseal build --exec "go run main.go" --output dist_opensealed

# Execution
openseal run --app dist_opensealed --port 3000
```

### ü¶Ä Rust
```bash
# Build (target folder is automatically ignored)
openseal build --exec "cargo run --release" --output dist_opensealed

# Execution
openseal run --app dist_opensealed --port 3000
```

### Step 4: Verify (Optional - For Testing)
```bash
# Verify the integrity of an API response
openseal verify --response result.json --wax "your-nonce-value" --root-hash "expected-a-hash"
```

**`result.json` File Format:**
The response file generated by OpenSeal runtime has the following structure:
```json
{
  "result": { /* Actual API response data */ },
  "openseal": {
    "signature": "...",  // Cryptographic signature
    "pub_key": "...",    // Public key for verification
    "a_hash": "...",     // Code identity hash
    "b_hash": "..."      // Result binding hash
  }
}
```

**What Gets Verified:**
- ‚úÖ **Signature**: Confirms `openseal.signature` is valid using `pub_key`
- ‚úÖ **Wax Match**: Ensures the Wax in the response matches the challenge sent
- ‚úÖ **Code Identity**: (if --root-hash provided) Verifies `a_hash` matches the expected code

**When to use `verify`:**
- Testing your sealed application locally before deployment
- Auditing API responses to ensure they contain valid Seals
- Debugging Seal generation issues

**Note**: In production, verification is typically done by the client (consumer) using the open-source verifier, not by the provider.

---

## 2. Safety Guardrails

OpenSeal prevents accidental sealing of unintended locations (like the home directory).

### Project Detection
The CLI checks for standard files (`package.json`, `Cargo.toml`, `.git`, etc.). If missing, it will request interactive confirmation:
> `‚ö†Ô∏è WARNING: No standard project files detected. Proceed anyway? (y/N)`

### Best Practices
- **Run at Root**: Always execute commands at the top-level directory of your source code.
- **Verify Exclusions**: Use `.opensealignore` to exclude large, non-essential folders like `node_modules`.

---

## 3. Rules for Exclusion
- **.opensealignore**: Completely excludes files from A-hash calculation (Code Privacy).
- **.openseal_mutable**: Seals the file's existence, but allows its content to change (e.g., logs, local DB).
