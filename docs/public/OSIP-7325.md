# OSIP-7325: OpenSeal Integrity Protocol

**Version**: 1.0.0
**Status**: Draft
**Port**: 7325 (Default)

---

## 1. Introduction

The **7325 Protocol** is a communication standard mathematically guaranteeing the integrity of remotely executed code. This protocol aims to assure verifiers that execution results submitted by a provider are generated from an "Agreed-upon Code Identity (GitHub Repository)" without requiring the verifier to execute the source code directly.

---

## 2. Roles and Responsibilities

### 2.1 Provider ("The Executor")
- **Identity Proof**: Provides access to the original source code (e.g., GitHub URL) during service registration.
- **Isolated Execution**: Executes business logic within the **OpenSeal Sanitized Environment** to block external interference.
- **Sealing**: Generates a **Signature** by including the execution result and the `Wax` (Challenge) provided by the verifier. **The provider is unaware of the detailed operation of the internal binding structure, preventing arbitrary result modification or signature forgery.**

### 2.2 Verifier ("The Oracle")
- **Root of Trust**: Clones the registered source code directly to extract a unique fingerprint (`RootHash`).
- **Asymmetric Verification**: Verifies the `Result` and `Signature` received from the provider against its known `RootHash` (A-Hash) in real-time. The verifier does not execute the business logic.

### 2.3 User ("The Consumer")
- **Result Reception**: Calls the API via the verifier.
- **Trust Acquisition**: Receives integrity verification fields guaranteed by the verifier along with the business result.

---

## 3. Protocol Flow

### Phase 1: Onboarding
1. Provider submits **GitHub Repository URL** to Verifier.
2. Verifier clones the repository in an isolated environment.
3. Verifier calculates the Merkle Root of the entire project to generate the **`RootHash`** and stores it.

### Phase 2: Request & Challenge
1. User sends an API request to Verifier.
2. Verifier generates an unpredictable random number **`Wax`**.
3. Verifier forwards `Request + Wax` to Provider.

### Phase 3: Execution & Signing
1. Provider node executes the API within the OpenSeal Runtime.
2. Upon completion, a **`Signature`** is generated including state identifiers such as `Result`, `Wax`, and `A-hash`.
3. Provider returns `Result + Signature` to Verifier.

### Phase 4: Verification & Final Response
1. Verifier computes the `Expected Signature` based on the received `Result` and its stored `RootHash`.
2. If the active signature matches the expected signature, an **Integrity Guarantee Mark** is included in the final response returned to the User.

---

## 4. Data Specification

### 4.1 Request Format
**Header Method (Recommended)**: Non-intrusive method dealing with existing API bodies.
```http
POST /api/endpoint HTTP/1.1
Host: provider.com
Content-Type: application/json
X-OpenSeal-Wax: <Verifier_Generated_Random_Hex>

{
  "key": "value" // (Optional) Original API business data
}
```

### 4.2 Response Format (Provider to Verifier)
The OpenSeal Runtime wraps the original response (`result`) with an integrity guarantee (`openseal`).
```json
{
  "result": { ... }, // Original Application JSON Response
  "openseal": {
    "signature": "Hex_Signature_String",  // Required: Integrity Signature
    "pub_key": "Hex_PublicKey",           // Required: Ephemeral Key for Verification
    "a_hash": "Hex_Blinded_Identity",     // Required: Execution Identity Identifier
    "b_hash": "Hex_Result_Binding"        // Required: Result Binding Identifier
  }
}
```

### 4.3 Response Format (Verifier to User)
(Reference) Example format delivered to end-user after verification.
```json
{
  "result": { ... },
  "security": {
    "certified": true,
    "timestamp": "ISO8601"
  }
}
```

---

## 5. Security Core Principles

1. **Logic Secrecy**: The source code is not exposed during verification, and the internal binding structure is treated as a **Black-box** to the provider. This is a key mechanism mathematically preventing the provider from fabricating results and generating matching fake signatures.
2. **Isolated Runtime**: All API executions occur within an **OpenSeal Isolated Context** where environment variables are sanitized (`env_clear`) and network ports are monopolized. This blocks external dynamic interference on the running code.
3. **Independent Fingerprinting**: The verifier does not trust inputs but extracts hashes directly from the source code to establish a Root of Trust.
4. **Real-time Binding**: All responses are bound to a one-time `Wax` to prevent Replay Attacks.
