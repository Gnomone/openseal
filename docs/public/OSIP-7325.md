# OSIP-7325: Integrity-Assured API Communication Protocol (OpenSeal Integrity Protocol)

**Version**: 1.0.0  
**Status**: Draft  
**Port**: 7325 (Default)

---

## 1. Introduction

The **7325 Protocol** is a communication standard mathematically designed to guarantee the integrity of code executing in remote locations. The goal of this protocol is for a verifier to ensure that the execution results submitted by a provider were generated from "agreed-upon code (GitHub Repository)" without having to execute the provider's source code directly.

---

## 2. Roles and Responsibilities

### 2.1 Provider ("The Executor")
- **Proof of Identity**: Provides access rights (GitHub URL) to the original source code during service registration.
- **Execution**: Performs business logic within the OpenSeal protective envelope.
- **Sealing**: Generates a signature by combining the execution result with the `Wax` (Challenge) provided by the verifier using highly obfuscated logic (`g_B`).

### 2.2 Verifier ("The Oracle")
- **Root of Trust**: Establishes a baseline by directly cloning the registered source code and extracting a unique fingerprint (`RootHash`).
- **Asymmetric Verification**: Performs real-time verification by contrasting the `Result` and `Signature` received from the provider with the stored `RootHash` and `g_B` logic. The business logic itself is not executed.

### 2.3 User ("The Consumer")
- **Receipt of Results**: Calls the API through the verifier proxy.
- **Gain Trust**: Receives the business result along with an integrity certification field guaranteed by the verifier.

---

## 3. Protocol Flow

### Phase 1: Onboarding (Fingerprinting)
1. The provider submits a **GitHub Repository URL** to the verifier.
2. The verifier clones the repository in an isolated environment.
3. The verifier calculates a Merkle Root for the entire project and stores the **`RootHash`** in its database.

### Phase 2: Request & Challenge
1. A user sends an API request to the verifier.
2. The verifier generates an unpredictable random number, the **`Wax`**.
3. The verifier passes the `Request + Wax` to the provider.

### Phase 3: Execution & Signing
1. The provider node executes the API within the OpenSeal runtime.
2. After execution, it generates a **`Signature`** by passing the `Result`, `Wax`, and `A-hash(RootHash+Wax)` through the `g_B` function.
3. The provider returns the `Result + Signature` to the verifier.

### Phase 4: Verification & Final Response
1. The verifier calculates the `Expected Signature` using the received `Result` and its stored `RootHash`.
2. If the received signature matches the calculated one, the verifier includes an **Integrity Assurance Mark** in the response and returns it to the user.

---

## 4. Data Specification

### 4.1 Request
```json
{
  "input": { ... },
  "openseal": {
    "wax": "string"  // Challenge generated by the verifier
  }
}
```

### 4.2 Response (Verifier to User)
```json
{
  "result": { ... },
  "openseal": {
    "integrity_certified": true,
    "signature_verified": true,
    "provider_identity": "PubKey_Hex",
    "timestamp": "ISO8601"
  }
}
```

---

## 5. Security Principles

1. **Logic Concealment**: Source code is not exposed during verification, and the binding logic (`g_B`) is protected via obfuscation.
2. **Independent Fingerprinting**: The verifier does not trust the input but extracts the hash directly from the source code to establish the root of trust.
3. **Real-time Binding**: Every response is bound to a one-time `Wax` to prevent replay attacks.
