# 🧶 OpenSeal: 언어 중립성 및 소스 무결성 (Language Agnosticism)

본 문서는 OpenSeal 프로토콜이 어떻게 특정 언어에 종속되지 않고 범용적인 무결성을 제공하는지, 그리고 왜 "빌드 결과물(`dist`) 대신 소스 코드(`src`)"를 검증하는지 설명합니다.

---

## 1. 핵심 철학: "Source is the Golden Truth"

많은 보안 솔루션이 최종 실행 파일(바이너리)의 해시를 확인합니다. 하지만 OpenSeal은 **원본 소스 코드**에 집중합니다.

### 왜 소스 코드인가?
1.  **감사 가능성 (Auditability)**: 개발자와 사용자가 읽고 검증할 수 있는 것은 바이너리가 아닌 소스 코드입니다.
2.  **재현 불가능성 해결**: 동일한 소스라도 컴파일러 버전, 빌드 시각, OS 환경에 따라 바이너리 해시는 달라질 수 있습니다. 소스를 기준으로 삼으면 불필요한 해시 불일치를 방지할 수 있습니다.
3.  **공급망 보안**: 빌드 아티팩트(`dist/`, `build/`)는 배포 과정에서 변조될 위험이 있습니다. OpenSeal은 검증된 소스에서 실행으로 바로 이어지는 "직통 경로"를 만듭니다.

---

## 2. 언어 중립적 설계 (Language Agnostic)

OpenSeal은 특정 프로그래밍 언어의 문법이나 런타임을 강요하지 않습니다. 대신 표준적인 프로젝트 구조를 자동으로 감지하고, 해당 언어의 관례에 맞는 최적의 무결성 보호 가이드를 제공합니다.

### 지원 전략
- **자동 감지**: `package.json`, `Cargo.toml`, `requirements.txt`, `go.mod` 등을 통해 프로젝트 성격을 파악합니다.
- **표준 제외 규칙**: 각 언어별 빌드 부산물(예: `node_modules`, `venv`, `target`)을 자동으로 무결성 검사 범위에서 제외하여, "순수한 로직(Logic)"만을 추출합니다.

---

## 3. 보안 실행 모델 (Security Model)

OpenSeal의 보안 무결성을 유지하면서 API를 배포하는 두 가지 핵심 패턴입니다.

### 패턴 A: JIT(Just-In-Time) 실행 (권장)
소스 코드를 자바스크립트나 바이너리로 변환하지 않고 런타임이 즉석에서 해석하여 실행합니다.
- **예**: TypeSript에서 `ts-node` 사용, Python에서 `python main.py` 사용.
- **장점**: 내가 본 코드(A-hash)가 곧바로 실행되는 코드가 됨을 100% 보장합니다.

### 패턴 B: 봉인된 환경 내 빌드
성능상의 이유로 컴파일이 필요한 경우, OpenSeal이 봉인(Seal)한 소스 코드 구역 안에서 직접 빌드를 수행하고 바로 실행합니다.
- **예**: `npm run build && npm start`
- **장점**: 실행 속도가 빠르며, 빌드 과정조차 OpenSeal의 통제 하에 있습니다.

---

## 4. 결론

OpenSeal은 언어의 장벽을 넘어, **"누가 이 API를 만들었는가"**에서 **"어떤 코드가 이 결과를 만들었는가"**로 신뢰의 중심을 옮깁니다. 우리는 모든 개발자가 자신이 작성한 코드의 가치를 증명할 수 있는 세상을 지향합니다.
