# OpenSeal Security Model & Defense

This document outlines the Threat Model assumed by the OpenSeal protocol and the multi-layered defense mechanisms employed to address them.

---

## 1. Core Security Objectives

OpenSeal aims to provide mathematical and structural assurance for the following question:

> **"Is this Result I received truly generated from the Agreed Source Code (Identity) at the time of my Request (Wax)?"**

To achieve this, we guarantee three properties:
1.  **Integrity**: The result has not been tampered with after generation.
2.  **Authenticity**: The executed code matches the original known to the verifier.
3.  **Freshness**: The result is not a replay of a past execution.

---

## 2. Threat Model

OpenSeal is designed to defend against the following attack scenarios:

### 2.1 Result Tampering & Forgery
*   **Scenario**: An attacker (malicious provider) returns a modified result without executing the code or after altering the output.
*   **Defense**:
    *   **Signature**: The result is signed with an ephemeral key, and the `Result` itself is included in the signature generation.
    *   **Binding Identifier (B-Hash)**: The result is internally bound with `A-Hash` and `Wax` to create a unique identifier. Since the attacker does not know the internal structure (`Sealed Logic`), they cannot generate a valid B-Hash for a forged result.

### 2.2 Replay Attack
*   **Scenario**: An attacker intercepts a valid past response and submits it as the response to a current request.
*   **Defense**:
    *   **Wax (Challenge)**: Every request includes a one-time random number (`Wax`) generated by the verifier.
    *   **Forced Binding**: The `Wax` is a mandatory component of the signature, so a response bound to an old `Wax` will fail verification against the current `Wax`.

### 2.3 Shadow Application Attack
*   **Scenario**: An attacker executes a `Fake Code` tailored to deceive the verifier instead of the `Main Code`.
*   **Defense**:
    *   **A-Hash Verification**: The OpenSeal Runtime hashes the entire project file set into a Merkle Tree to generate a `Root Hash` immediately before execution.
    *   **Identity Mismatch**: The verifier compares its known `Root Hash` (derived from the original source) with the `A-Hash` reported by the runtime. Any discrepancy results in immediate rejection.

### 2.4 Environment Poisoning
*   **Scenario**: An attacker manipulates `LD_PRELOAD`, `PYTHONPATH`, etc., to hijack the execution environment or swap libraries.
*   **Defense**:
    *   **Environment Sanitization**: The OpenSeal Runtime initializes all environment variables via `env_clear()` before spawning the child process, injecting only whitelisted variables.

---

## 3. Architectural Defense

### 3.1 Caller Monopoly
*   The OpenSeal Runtime is designed as a **"Disposable Process"**, not a daemon.
*   The runtime and the internal app terminate immediately after one request-response cycle.
*   This prevents Memory Resident Attacks and the persistence of state corruption.

### 3.2 Ephemeral Keys
*   OpenSeal does not use long-term "Master Keys".
*   An `Ephemeral Keypair` based on random entropy is generated in memory for each execution and destroyed immediately after signing.
*   This eliminates the risk of key compromise due to mismanagement.

---

## 4. Verifier's Responsibility

OpenSeal operates on the assumption that "The Verifier knows the Root Hash."
Therefore, the verifier must obtain the source code through a **Trusted Channel (e.g., GitHub)** and compute the hash directly. The verifier should never blindly trust the hash provided by the provider.
