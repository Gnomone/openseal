# OpenSeal: 신뢰할 수 없는 하드웨어 위에서의 실행 정직성 강제
**OpenSeal 백서 (Whitepaper) v2.0**

[🇺🇸 English Version](./WHITEPAPER.md)

> "반환값은 데이터로 신뢰받지 않는다 — 그것은 봉인된 런타임 내부의 상태 주장(Assertion)으로 소비될 뿐이다."

---

## 1. 개요 (Abstract)

현대 AI 경제는 유료 API(x402)에 의존하고 있지만, 지불과 **"실행의 정직성(Honesty of Execution)"** 사이에는 검증 가능한 연결고리가 없습니다. TEE(신뢰 실행 환경)나 ZK(영지식 증명)와 같은 기존 솔루션은 일반 목적의 API 검증에 적용하기에는 너무 무겁거나 느리고, 특수 하드웨어에 종속적입니다.

OpenSeal은 **"원자적 프로젝트 봉인 (Atomic Project Sealing)"**을 보장하는 경량화된 소프트웨어 기반 암호화 프로토콜을 제안합니다. API의 결과를 단순한 '값'이 아닌 **'상태 전이의 증거'**로 재정의함으로써, OpenSeal은 제공자가 특수 하드웨어 없이도 "사전에 약속된 코드가 실제로 실행되어 이 결과를 낳았음"을 증명하도록 강제합니다.

---

## 2. 위협 모델 (Threat Model)

우리는 다음과 같은 적대적 환경을 가정합니다:
1.  **운영자는 악의적이다 (Malicious Operator)**: API 제공자는 비용을 절감하기 위해 캐싱된 데이터, 모조 데이터, 또는 저성능 모델의 출력을 반환하면서 정가(Full Price)를 청구하려 합니다.
2.  **네트워크는 불안정하다 (Insecure Network)**: 공격자(MITM)가 중간에서 결과를 가로채거나 변조하려 합니다.
3.  **클라이언트는 눈이 멀었다 (Blind Client)**: 호출자는 오직 결과만 받을 뿐, 서버의 런타임 메모리를 들여다볼 수 없습니다.

OpenSeal은 이러한 조건 하에서 **"약속된 코드의 정직한 실행에서 1비트라도 벗어나는 행위"**를 감지하는 것을 목표로 합니다.

---

## 3. 문제 정의: 검증 불가능한 간극

표준 API 호출 과정은 다음과 같습니다:
*   Client 요청: `Function(Input)`
*   Server 반환: `Result`

여기서 간극(Gap)이 발생합니다: **`Result`는 `Function(Input)`이 실행되었다는 증거가 아닙니다.**
서버는 `Mock(Input)`이나 `Cache(Input)`을 실행했을 수도 있습니다. TLS와 같은 기존 암호화 서명은 데이터를 *누가* 보냈는지는 증명하지만, *어떻게* 생성되었는지는 증명하지 못합니다.

---

## 4. 핵심 통찰 (Core Insight)

OpenSeal은 두 가지 근본적인 발상의 전환으로 이 간극을 메웁니다:

### A. 상태 전이로서의 결과 (Result as State Transition)
우리는 실행 출력을 읽어야 할 "데이터"가 아니라, 런타임의 **"상태 전이(State Transition)"**로 취급합니다. 결과는 생성 즉시 봉인 계층에 의해 소비(Consume)되어 프로젝트의 정체성과 결합됩니다.

### B. 불가분한 결합 (Indissoluble Binding)
실행 로직인 `L`, 입력이 `I`, 결과가 `R`일 때:
전통적인 서명은 `Sign(R)`입니다.
OpenSeal은 `Seal(L + I + R)`입니다.
`L`과 `I`의 올바른 상태를 점유하지 않고서는, `R`에 대한 유효한 Seal을 생성할 수 없습니다.

---

## 5. OpenSeal 모델

OpenSeal은 이 통찰을 엄격한 원자적 파이프라인으로 구현합니다:

1.  **사전 상태 약속 (Pre-State Commitment)**:
    실행 전, 전체 코드베이스(프로젝트 디렉토리)가 머클 루트(`A-hash`)로 해싱됩니다. 이것이 로직의 "정체성(Identity)"을 정의합니다.

2.  **원자적 실행 경계 (Atomic Execution Boundary)**:
    OpenSeal 런타임은 실행 컨텍스트를 독점(Caller Monopoly)합니다. 런타임은 부모 프로세스로서 일회성 실행 토큰(`Wax`)을 주입하고 감시합니다.

3.  **단방향 봉인 (One-Way Sealing)**:
    실행 완료 즉시, 런타임은 결과를 포착하여 정체성(`A`) 및 Wax(`W`)와 함께 **동적 비재현 함수**를 통해 결합합니다.

4.  **사후 상태 주장 (Post-State Assertion)**:
    최종 출력물인 `Seal`은 다음을 주장합니다: *"이 결과는 프로젝트 A가 입력 I와 Wax W를 가지고 실행된 필연적인 결과이다."*

---

## 6. 보안 논증 (Security Argument)

OpenSeal의 보안은 **경제적 비대칭성(Economic Asymmetry)**에 의존합니다:

*   **정직한 실행 비용**: $C_{run}$ (컴퓨팅 자원 + 표준 프로토콜 오버헤드)
*   **위조 비용**: $C_{forge}$ (동적 봉인 로직 역공학 + 실시간 메모리 탈취 + 그림자 상태 구성)

OpenSeal의 설계 목표는 다음과 같습니다:
$$ C_{forge} \gg C_{run} $$

봉인 로직($b\_G$)은 요청마다 동적으로 변화하며 런타임 상태와 강력하게 결합되어 있기 때문에, 공격자가 가짜 결과에 대한 유효한 봉인을 위조하려면 정직한 실행 환경 전체를 캡슐화하고 시뮬레이션해야 합니다. 따라서, **"정직하게 코드를 실행하는 것이 언제나 더 싸다"**는 경제적 합리성을 강제합니다.

---

## 7. OpenSeal이 보장하지 않는 것 (한계 선언)

투명성을 위해, 우리는 이 프로토콜의 한계를 명확히 정의합니다:

1.  **의미론적 올바름 (Semantic Correctness)**: OpenSeal은 *코드가 실행되었음*을 증명할 뿐, *코드가 훌륭하다*는 것을 증명하지 않습니다. 코드에 버그가 있다면, Seal은 그 버그가 포함된 결과를 정직하게 증명합니다.
2.  **데이터 원천의 진실성 (Data Source Truth)**: 코드가 외부 오라클(예: DB)에서 데이터를 가져오는 경우, OpenSeal은 *가져오는 행위*를 보증할 뿐, *DB 데이터가 참*임을 보증하지 않습니다.
3.  **커널 공격에 대한 방어**: 커널 레벨의 메모리 접근 권한을 가진 ROOT 공격자는 이론적으로 소프트웨어 방어를 우회할 수 있습니다. OpenSeal은 "상업적 무결성(사기 방지)"을 목표로 하며, "군사 등급의 봉인(국가적 행위자 방어)"을 목표로 하지 않습니다.

---

## 8. 철학: 검증의 민주화, 생성의 독점

OpenSeal v2.0은 엄격한 공개 정책을 따릅니다:

*   **검증은 민주적이다 (Verification is Democratic)**: Seal의 유효성을 확인하는 규칙(`Result` + `Seal` -> `OK/FAIL`)은 완전히 공개되어 있으며 누구나 검증할 수 있습니다.
*   **생성은 독점적이다 (Generation is Monopolized)**: Seal이 *어떻게* 구성되는지에 대한 내부 메커니즘(배합 레시피, 동적 함수)은 공개되지 않거나 추상화됩니다. 이는 "그림자 생성기(Shadow Generator)"가 정직한 실행 요구사항을 우회하는 것을 방지하기 위함입니다.

> **"우리는 신뢰를 민주화하지만, 작업 증명(Proof of Work)은 독점한다."**
