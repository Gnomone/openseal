# 📜 OpenSeal: 기술 진화의 기록 (Project Evolution History)

이 문서는 OpenSeal이 '신뢰할 수 있는 API'라는 목표를 달성하기 위해 거쳐온 세 번의 거대한 기술적 변곡점과 각 단계에서의 고민, 기각된 아이디어들을 기록합니다.

---

## 1단계: 머클 트리 기반 소스 무결성 (v1.0)
**"코드가 변하지 않았다면 그 결과도 믿을 수 있는가?"**

*   **배경**: 단순히 소스코드와 결과값의 해시를 결합하여 서명하는 방식에서 시작.
*   **시도**: 프로젝트 파일들을 머클 트리(Merkle Tree)로 빌드하고 그 Root Hash를 `CodeIdentity`로 사용.
*   **문제점**: 
    *   **실행의 불확실성**: 코드가 정직하더라도, 실행 중에 메모리를 조작하거나 입력을 가짜로 주입하는 행위를 막을 수 없음.
    *   **결정성(Determinism) 부족**: 같은 코드라도 시간, 난수, 환경 변수에 따라 결과가 달라지는데 이를 검증할 방법이 부족함.
*   **결과**: **기각.** "코드 무결성 != 실행 무결성"임을 깨달음.

---

## 2단계: WASM 기반 샌드박싱 (v2.0 Beta)
**"완벽하게 격리된 결정적 런타임이 정답인가?"**

*   **배경**: WASM(WebAssembly)의 결정적 런타임 특성을 이용해 외부 간섭이 불가능한 '금고'를 제작.
*   **시도**: `openseal-runtime`을 구축하고 모든 로직을 WASM으로 강제 변환.
*   **장점**: 메모리 격리, Fuel 기반 연산량 제어, 부동소수점 오차 방지 등 수학적 완벽함 추구.
*   **치명적 한계 (Blockers)**:
    1.  **네트워크 단절**: WASM 내부에서 API 호출(`fetch`)이 불가능하여 BTC 가격 조회 같은 실시간 데이터 연동이 매우 복잡해짐.
    2.  **개발자 경험(DX) 최악**: JS/Python 개발자가 보안을 위해 Rust를 배워야 함.
    3.  **오라클 공격**: 런타임(운영자)이 가짜 `A-hash`를 주입하여 WASM을 속이는 '가스라이팅' 공격을 원천 차단하기 어려움.
    4.  **껍데기 문제**: WASM은 '금고'지만, 금고를 배달하는 배달원(JS/Python)이 바깥에서 로직을 가로채거나 가짜 데이터를 전달하는 것을 막지 못함.
*   **결과**: **전면 재검토.** "보안 엔진은 튼튼하나 현실적인 도구로서의 가치가 낮음."

---

## 3단계: 원자적 프로젝트 봉인 & 호출자 독점 (v2.0 Final)
**"사건(Event)을 관(Case)에서 분리하고, 호출 경계를 장악하라"**

*   **최종 기획**: WASM을 버리고 프로젝트 전체를 머클 트리로 묶되, **호출자(Caller)를 대체하는 런타임** 모델 채택.
*   **핵심 철학**: 
    *   **WASM is gone**: 네이티브 성능과 네트워크 접근을 보장하는 암호화된 런타임으로 전환.
    *   **Caller Monopoly**: OpenSeal은 코드를 고치지 않음. 대신 코드를 호출하는 **부모 프로세스(Caller)**를 대체하여 입/출력을 독점함.
    *   **Return as State Transition**: API의 반환값은 데이터가 아니라, 봉인 캡슐 내부의 '상태 전이'로 취급함.

### 💡 주요 논의 및 기각된 아이디어들

1.  **소스코드 자동 변조 (Instrumentation)**:
    *   *내용*: 개발자 코드 사이사이에 해시 생성 코드를 자동으로 심는 방식.
    *   *기각 사유*: 디버깅이 어렵고 유지보수가 불가능함. "코드를 고치는 행위는 하책(下策)이다."
2.  **WASM HTTP Oracle Shim**:
    *   *내용*: WASM 내부 요청을 호스트가 릴레이해 주는 복잡한 구조.
    *   *기각 사유*: 구현이 너무 무겁고, 외부 라이브러리(requests 등)의 호환성을 맞추기 어려움.
3.  **TEE (Intel SGX) 필수화**:
    *   *내용*: 하드웨어 보안 장치 없이는 무결성을 주장하지 말자.
    *   *기각 사유*: 배포 환경의 제약이 너무 심함. 소프트웨어적으로 **"위조 비용 >= 실행 비용"**을 달성하는 것이 더 실무적임.

### 🧩 사용자(USER)와 논의된 핵심 통찰

*   **사건(Event) vs 관(Case)**: "WASM은 사건이고, JS/Python은 관이다. 사건이 일어난 곳을 못 건드리면 관을 아무리 바꿔도 의미가 없다."
*   **g(R)의 위상**: 봉인함수 `g`는 정적 수식이 아니라, 실행과 동시에 생성되는 **실행 궤적(Trace)** 그 자체여야 함.
*   **원자적 샌드위치**: `[A-hash 생성] -> [로직 실행] -> [B-hash 결합]` 과정을 암호화된 단일 파이프라인으로 묶어 떨어지지 않게 함.

---

## 마침표: "실행하는 것이 곧 증명하는 것이다"

OpenSeal은 이제 단순한 라이브러리가 아닙니다. 모든 API 서비스를 위한 **'신뢰의 외골격(Exoskeleton)'**으로 정의되었습니다.

*   **성능**: 네이티브 대비 지연시간 1ms 미만, 용량 증가 10MB 미만.
*   **보안**: 경제적 무결성 완성 (The High Cost of Lying).
*   **혁신**: 소스코드 수정 없는 완전 자동 봉인 API 서버.

**역사가 기록되었으므로, 이제 과거의 파편을 밀어내고 이 고결한 철학을 실제 코드로 구현합니다.**
